# 红黑树

![红黑树例子](images/红黑树/红黑树例子.png)

红黑树也是一种自平衡二叉搜索树

以前也叫做平衡二叉B树

红黑树必须满足一下5个性质

* 节点是有颜色的**Red**/**Black**

* 根节点必须是**Black**

* 叶子节点必须是**Black** 
  * 红黑树的叶子节点会自动将度为0 或者度为1的节点的度自动补充为2，补充的节点称之为外部节点
    * 外部节点是空想出来的，代码中不会实现
  
* **red**节点的子节点都是**black**色

* 从任意一节点到叶子节点的所有路径包含的**black**节点**数目相同**

  * 这里说的叶子节点包含假想出来的叶子节点
  



## 一、判断下面是否为红黑树

![判断是否为红黑树](images/红黑树/判断是否为红黑树.png)

  

* 不是

  满足

  - 节点是有颜色的**Red**/**Black**
  - 根节点必须是**Black**
  - 叶子节点必须是**Black** 
    - 红黑树的叶子节点会自动将度为0 或者度为1的节点的度自动补充为2，补充的节点称之为外部节点
      - 外部节点是空想出来的，代码中不会实现
  - **red**节点的子节点都是**black**色

* 不满组

  * 从任意一节点到叶子节点的所有路径包含的**black**节点**数目相同**
  
    <img src="images/红黑树/解释不是红黑树.png" alt="解释不是红黑树.png" style="zoom:50%;" />

## 二、红黑树的等价变换

![image-20191016142303985](images/红黑树/红黑树的等价变换.png)

* 红黑树和4阶B树具有等价性

  * **Black**节点与他的**Red**子节点融合在一起，就形成一个B树节点

* 红黑树的**Black**节点个数与4阶B树的节点总数相等

  

## 三、红黑树的操作

### 1、添加

* 想像成4阶B树
  * 添加操作都在叶子节点中。
  * 4阶B树所有节点的元素个数为 `1 <= x <= 3`。
* 建议新添加的节点默认为`Red` （这样能更快的满足红黑树的性质）。
* 根节点默认为`Black`。



所有的添加情况如下图所示

<img src="images/红黑树/添加时所有叶子节点情况.png" alt="image-20191016155819849" style="zoom: 50%;" />





#### 添加情况处理：

##### a、当parent为`black`的情况，直接添加，无需特殊处理。（4种情况）

![image-20191016160839147](images/红黑树/添加时情况1.png)

##### b、当parent为`Red`的情况。有以下几种情况（8种）

###### 1、当uncle节点为`Black`时

* RR/LL情况

  * 先对parent染成黑色，在对grand染红（染色的意义是在与让后面旋转后parent的节点为黑色，parent的子节点为黑色）
  * 当RR/LL情况的时候，需要对其进行左旋转/右旋转。（grand变成parent的子节点）。
  * 情况如下图所示:
    * <img src="images/红黑树/8中DoubleRed情况1.png" alt="8中DoubleRed情况1" style="zoom: 50%;" />

  

* LR\RL情况

  * 将自己染成`Black`，grand染成`Red` 。（染色的意义是进行后面的双旋转操作后自己成为parent节点，规定partent的节点为黑色，parent的子节点（原来的parent和grand）为Red。）。
  * 进行双选转
    * LR:parent左旋转，grand右旋转。
    * RL:parent右旋转，grand左旋转。
  * 情况如下图所示:
    * <img src="images/红黑树/8中DoubleRed情况2.png" alt="8中DoubleRed情况2" style="zoom: 50%;" />

###### 2、当uncle节点为`Red`时

当uncle为Red的时候，红黑树对比4阶B树会发生上溢操作。

* 将parent、uncle染成`Black`。（为了单独为一个节点做准备）。
* 将grand向上合并
* 将grand染成Red。当做是新节点进行处理。（递归，递归的代码只是染色，而旋转操作只做了1遍）
* 情况如下图所示:

<img src="images/红黑树/8中DoubleRed情况6.png" alt="image-20191016173323809" style="zoom: 50%;" />



### 2、删除

在B树中真正删除的元素都在叶子节点



![删除操作示例图](images/红黑树/删除操作示例图.png)

#### 添加情况处理：

##### a、当删除的是`Red`节点的时候

* 可以直接删除 无需其他操作

##### b、删除`Black`节点的时候

* 当拥有2个`Red`子节点的black节点

  * 不可能直接删除、因为平衡二叉树要找到2个度节点的前驱或者后继、替换后删除的是前驱或者后继。（所以不用考虑这个情况）。

* 当拥有1个`Red`子节点的black节点

  * 判断条件：用代替的子节点是`Red`
  * 将替代的的子节点染成`Black`
  * 情况如下图所示(删除46 和76) 直接55->50  80->72
  * ![删除情况1](images/红黑树/删除情况1.png)

* `Black`叶子节点

  * 如果Black叶子节点的兄弟节点为`Black`

    * 兄弟节点有红色节点

      * 叶子节点被删除后、可能导致B树下溢（删除88节点）
      * 进行旋转操作，旋转之后中心节点继承parent的颜色
      * 旋转之后左右节点染色为`Black`
      * ![image-20191017162519866](images/红黑树/删除操作下溢1.png)

    * 兄弟节点没有红色节点

      * 将兄弟节点染`Red`、parent节点染`Black` 既可。

        * 如果parent为`Black`, 会导致下溢，只需要把parent当做被删除的节点处理既可（递归）实验可得 递归次数小于三次。

        * <img src="images/红黑树/删除情况2.png" alt="删除情况2" style="zoom:50%;" />
    
  * 如果Black叶子节点的兄弟节点为`Red`
    * 将兄弟节点染成`Black` ,parent染成`Red`,再进行旋转。

    * 回到了兄弟节点为black的情况。

    * ![删除情况3](images/红黑树/删除情况3.png)

      

### 四、红黑树的平衡

![红黑树的平衡](images/红黑树/红黑树的平衡.png)

红黑树是一种弱平衡。黑高度平衡

红黑树的最大高度是$2 * log2^{n + 1}$，依然是O(logn)级别。





### 五、时间复杂度

搜索：O(logn)

添加：O(logn)，O(1)次旋转操作

删除：O(logn)，O(1)次旋转操作



### 六、AVL树VS红黑树

* AVL

  * 平衡标准比较严格：每个左右子树高度差1。

  * 最大高度是$1.44 * log2^{(n + 2)} - 1.328$(100W个节点，AVL最大高度28)。
  * 搜索、添加、删除都是O(logn)复杂度，其中添加需要O(1)次旋转调整、删除最多需要O(logn)次调整。

* 红黑树

  * 平衡标准比较松：没有一条路径大于其他路径的二倍。
  * 最大高度是$2 * log2^{(n + 1)} $(100W个节点，红黑树最大高度40)。

  * 搜索、添加、删除都是O(logn)复杂度，其中添加删除都是O(1)次旋转调整。

* 搜索的次数远大于插入和删除、选择AVL树；

* 搜索、插入、删除的操作差不多，选择红黑树；

* 相对于AVL，红黑树牺牲了部分平衡性能换取插入/删除时的少量旋转操作。整体性能优于AVL树

* 红黑树的平均统计性能优于AVL树，实际应用更多选择红黑树。

